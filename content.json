{"meta":{"title":"CharonZR","subtitle":"","description":"","author":"ZhouRui","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-15T11:01:42.894Z","updated":"2021-07-15T11:01:42.894Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":"123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"书单","date":"2021-07-12T08:00:15.214Z","updated":"2021-07-12T08:00:15.214Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-12T08:00:15.213Z","updated":"2021-07-12T08:00:15.213Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2021-07-12T08:00:15.214Z","updated":"2021-07-12T08:00:15.214Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-12T08:00:15.215Z","updated":"2021-07-12T08:00:15.215Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-12T08:00:15.216Z","updated":"2021-07-12T08:00:15.216Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-12T08:00:15.215Z","updated":"2021-07-12T08:00:15.215Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"读懂JMM","slug":"读懂JMM","date":"2021-08-09T09:59:39.000Z","updated":"2021-08-09T10:32:53.631Z","comments":true,"path":"2021/08/09/读懂JMM/","link":"","permalink":"http://example.com/2021/08/09/%E8%AF%BB%E6%87%82JMM/","excerpt":"","text":"什么是JMMJMM就是Java内存模型(java memory model)。因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。所以java内存模型(JMM)屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。 Java内存模型规定所有的变量都存储在主内存中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。线程不能直接读写主内存中的变量。 不同的线程之间也无法访问对方工作内存中的变量。线程之间变量值的传递均需要通过主内存来完成。 如果听起来抽象的话，我可以画张图给你看看，会直观一点： 每个线程的工作内存都是独立的，线程操作数据只能在工作内存中进行，然后刷回到主存。这是 Java 内存模型定义的线程基本工作方式。 JMM定义了什么整个Java内存模型实际上是围绕着三个特征建立起来的。分别是：原子性，可见性，有序性。这三个特征可谓是整个Java并发的基础。 原子性原子性指的是一个操作是不可分割，不可中断的，一个线程在执行时不会被其他线程干扰。 面试官拿笔写了段代码，下面这几句代码能保证原子性吗？ 1234int i = 2;int j = i;i++;i = i + 1; 第一句是基本类型赋值操作，必定是原子性操作。 第二句先读取i的值，再赋值到j，两步操作，不能保证原子性。 第三和第四句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。 JMM只能保证基本的原子性，如果要保证一个代码块的原子性，提供了monitorenter 和 moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。 可见性可见性指当一个线程修改共享变量的值，其他线程能够立即知道被修改了。Java是利用volatile关键字来提供可见性的。 当变量被volatile修饰时，这个变量被修改后会立刻刷新到主内存，当其它线程需要读取该变量时，会去主内存中读取新值。而普通变量则不能保证这一点。 除了volatile关键字之外，final和synchronized也能实现可见性。 synchronized的原理是，在执行完，进入unlock之前，必须将共享变量同步到主内存中。 final修饰的字段，一旦初始化完成，如果没有对象逸出（指对象为初始化完成就可以被别的线程使用），那么对于其他线程都是可见的。 有序性在Java中，可以使用synchronized或者volatile保证多线程之间操作的有序性。实现原理有些区别： volatile关键字是使用内存屏障达到禁止指令重排序，以保证有序性。 synchronized的原理是，一个线程lock之后，必须unlock后，其他线程才可以重新lock，使得被synchronized包住的代码块在多线程之间是串行执行的。 MM模型下的线程间通信：线程间通信必须要经过主内存。 如下，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤： 1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。 2）线程B到主内存中去读取线程A之前已更新过的共享变量。 关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成： lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。 unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。 write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则： 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。 Java内存模型解决的问题当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。Java内存模型建立所围绕的问题：在多线程并发过程中，如何处理多线程读同步问题与可见性（多线程缓存与指令重排序）、多线程写同步问题与原子性（多线程竞争race condition）。 1、多线程读同步与可见性 可见性（共享对象可见性）：线程对共享变量修改的可见性。当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改 线程缓存导致的可见性问题： 如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，一个线程更新这个共享对象可能对其它线程来说是不可见的：共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中，然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。 下图示意了这种情形。跑在左边CPU的线程拷贝这个共享对象到它的CPU缓存中，然后将count变量的值修改为2。这个修改对跑在右边CPU上的其它线程是不可见的，因为修改后的count的值还没有被刷新回主存中去。 解决这个内存可见性问题你可以使用： Java中的volatile关键字：volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是：volatile的特殊规则保证了新值能立即同步到主内存，以及每个线程在每次使用volatile变量前都立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。 Java中的synchronized关键字：同步快的可见性是由“如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值”、“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）”这两条规则获得的。 Java中的final关键字：final关键字的可见性是指，被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程就能看见final字段的值（无须同步） 重排序导致的可见性问题： Java程序中天然的有序性可以总结为一句话：如果在本地线程内观察，所有操作都是有序的（“线程内表现为串行”(Within-Thread As-If-Serial Semantics)）；如果在一个线程中观察另一个线程，所有操作都是无序的（“指令重排序”现象和“线程工作内存与主内存同步延迟”现象）。 Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性： volatile关键字本身就包含了禁止指令重排序的语义 synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入 指令序列的重排序： 1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作进行重排序： 数据依赖： 编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。（这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑） 指令重排序对内存可见性的影响： 当1和2之间没有数据依赖关系时，1和2之间就可能被重排序（3和4类似）。这样的结果就是：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。 指令重排序改变多线程程序的执行结果例子： flag变量是个标记，用来标识变量a是否已被写入。这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()方法。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入呢？ 答案是：不一定能看到。 由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。 as-if-serial语义： 不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。（编译器、runtime和处理器都必须遵守as-if-serial语义） happens before： 从JDK 5开始，Java使用新的JSR-133内存模型，JSR-133使用happens-before的概念来阐述操作之间的内存可见性：在JMM中，如果一个操作执行的结果需要对另一个操作可见（两个操作既可以是在一个线程之内，也可以是在不同线程之间），那么这两个操作之间必须要存在happens-before关系： 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 一个happens-before规则对应于一个或多个编译器和处理器重排序规则 内存屏障禁止特定类型的处理器重排序： 重排序可能会导致多线程程序出现内存可见性问题。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。 为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。 StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。现代的多处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（Buffer Fully Flush）。 2、多线程写同步与原子性 多线程竞争（Race Conditions）问题：当读，写和检查共享变量时出现race conditions。 如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。 想象一下，如果线程A读一个共享对象的变量count到它的CPU缓存中。再想象一下，线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增加了两次，每个CPU缓存中一次。如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次： 解决这个问题可以使用Java同步块。一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。 使用原子性保证多线程写同步问题： 原子性：指一个操作是按原子的方式执行的。要么该操作不被执行；要么以原子方式执行，即执行过程中不会被其它线程中断。 实现原子性： 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write，我们大致可以认为基本数据类型变量、引用类型变量、声明为volatile的任何类型变量的访问读写是具备原子性的（long和double的非原子性协定：对于64位的数据，如long和double，Java内存模型规范允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，即如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。但由于目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此在编写代码时一般也不需要将用到的long和double变量专门声明为volatile）。这些类型变量的读、写天然具有原子性，但类似于 “基本变量++” / “volatile++” 这种复合操作并没有原子性。 如果应用场景需要一个更大范围的原子性保证，需要使用同步块技术。Java内存模型提供了lock和unlock操作来满足这种需求。虚拟机提供了字节码指令monitorenter和monitorexist来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步快——synchronized关键字。","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]},{"title":"初探Nginx架构","slug":"初探Nginx架构","date":"2021-08-04T03:20:56.000Z","updated":"2021-08-04T03:21:52.989Z","comments":true,"path":"2021/08/04/初探Nginx架构/","link":"","permalink":"http://example.com/2021/08/04/%E5%88%9D%E6%8E%A2Nginx%E6%9E%B6%E6%9E%84/","excerpt":"","text":"初探 Nginx 架构众所周知，Nginx 性能高，而 Nginx 的高性能与其架构是分不开的。那么 Nginx 究竟是怎么样的呢？这一节我们先来初识一下 Nginx 框架吧。 Nginx 在启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程。我们也可以手动地关掉后台模式，让 Nginx 在前台运行，并且通过配置让 Nginx 取消 master 进程，从而可以使 Nginx 以单进程方式运行。很显然，生产环境下我们肯定不会这么做，所以关闭后台模式，一般是用来调试用的，在后面的章节里面，我们会详细地讲解如何调试 Nginx。所以，我们可以看到，Nginx 是以多进程的方式来工作的，当然 Nginx 也是支持多线程的方式的，只是我们主流的方式还是多进程的方式，也是 Nginx 的默认方式。Nginx 采用多进程的方式有诸多好处，所以我就主要讲解 Nginx 的多进程模式吧。 刚才讲到，Nginx 在启动后，会有一个 master 进程和多个 worker 进程。master 进程主要用来管理 worker 进程，包含：接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态，当 worker 进程退出后(异常情况下)，会自动重新启动新的 worker 进程。而基本的网络事件，则是放在 worker 进程中来处理了。多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求。worker 进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与 Nginx 的进程模型以及事件处理模型是分不开的。Nginx 的进程模型，可以由下图来表示： 在 Nginx 启动后，如果我们要操作 Nginx，要怎么做呢？从上文中我们可以看到，master 来管理 worker 进程，所以我们只需要与 master 进程通信就行了。master 进程会接收来自外界发来的信号，再根据信号做不同的事情。所以我们要控制 Nginx，只需要通过 kill 向 master 进程发送信号就行了。比如kill -HUP pid，则是告诉 Nginx，从容地重启 Nginx，我们一般用这个信号来重启 Nginx，或重新加载配置，因为是从容地重启，因此服务是不中断的。master 进程在接收到 HUP 信号后是怎么做的呢？首先 master 进程在接到信号后，会先重新加载配置文件，然后再启动新的 worker 进程，并向所有老的 worker 进程发送信号，告诉他们可以光荣退休了。新的 worker 在启动后，就开始接收新的请求，而老的 worker 在收到来自 master 的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。当然，直接给 master 进程发送信号，这是比较老的操作方式，Nginx 在 0.8 版本之后，引入了一系列命令行参数，来方便我们管理。比如，./nginx -s reload，就是来重启 Nginx，./nginx -s stop，就是来停止 Nginx 的运行。如何做到的呢？我们还是拿 reload 来说，我们看到，执行命令时，我们是启动一个新的 Nginx 进程，而新的 Nginx 进程在解析到 reload 参数后，就知道我们的目的是控制 Nginx 来重新加载配置文件了，它会向 master 进程发送信号，然后接下来的动作，就和我们直接向 master 进程发送信号一样了。 现在，我们知道了当我们在操作 Nginx 的时候，Nginx 内部做了些什么事情，那么，worker 进程又是如何处理请求的呢？我们前面有提到，worker 进程之间是平等的，每个进程，处理请求的机会也是一样的。当我们提供 80 端口的 http 服务时，一个连接请求过来，每个进程都有可能处理这个连接，怎么做到的呢？首先，每个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面，先建立好需要 listen 的 socket（listenfd）之后，然后再 fork 出多个 worker 进程。所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当一个 worker 进程在 accept 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由 worker 进程来处理，而且只在一个 worker 进程中处理。 那么，Nginx 采用这种进程模型有什么好处呢？当然，好处肯定会很多了。首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的 worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。当然，好处还有很多，大家可以慢慢体会。 上面讲了很多关于 Nginx 的进程模型，接下来，我们来看看 Nginx 是如何处理事件的。 有人可能要问了，Nginx 采用多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，那能够处理的并发数很有限啊，多少个 worker 就能处理多少个并发，何来高并发呢？非也，这就是 Nginx 的高明之处，Nginx 采用了异步非阻塞的方式来处理请求，也就是说，Nginx 是可以同时处理成千上万个请求的。想想 apache 的常用工作方式（apache 也有异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），每个请求会独占一个工作线程，当并发数上到几千时，就同时有几千的线程在处理请求了。这对操作系统来说，是个不小的挑战，线程带来的内存占用非常大，线程的上下文切换带来的 cpu 开销很大，自然性能就上不去了，而这些开销完全是没有意义的。 为什么 Nginx 可以采用异步非阻塞的方式来处理呢，或者异步非阻塞到底是怎么回事呢？我们先回到原点，看看一个请求的完整过程。首先，请求过来，要建立连接，然后再接收数据，接收数据后，再发送数据。具体到系统底层，就是读写事件，而当读写事件没有准备好时，必然不可操作，如果不用非阻塞的方式来调用，那就得阻塞调用了，事件没有准备好，那就只能等了，等事件准备好了，你再继续吧。阻塞调用会进入内核等待，cpu 就会让出去给别人用了，对单线程的 worker 来说，显然不合适，当网络事件越多时，大家都在等待呢，cpu 空闲下来没人用，cpu利用率自然上不去了，更别谈高并发了。好吧，你说加进程数，这跟apache的线程模型有什么区别，注意，别增加无谓的上下文切换。所以，在 Nginx 里面，最忌讳阻塞的系统调用了。不要阻塞，那就非阻塞喽。非阻塞就是，事件没有准备好，马上返回 EAGAIN，告诉你，事件还没准备好呢，你慌什么，过会再来吧。好吧，你过一会，再来检查一下事件，直到事件准备好了为止，在这期间，你就可以先去做其它事情，然后再来看看事件好了没。虽然不阻塞了，但你得不时地过来检查一下事件的状态，你可以做更多的事情了，但带来的开销也是不小的。所以，才会有了异步非阻塞的事件处理机制，具体到系统调用就是像 select/poll/epoll/kqueue 这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。这种机制正好解决了我们上面的两个问题，拿 epoll 为例(在后面的例子中，我们多以 epoll 为例子，以代表这一类函数)，当事件没准备好时，放到 epoll 里面，事件准备好了，我们就去读写，当读写返回 EAGAIN 时，我们将它再次加入到 epoll 里面。这样，只要有事件准备好了，我们就去处理它，只有当所有事件都没准备好时，才在 epoll 里面等着。这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。与多线程相比，这种事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常的轻量级。并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。 我之前有对连接数进行过测试，在 24G 内存的机器上，处理的并发请求数达到过 200 万。现在的网络服务器基本都采用这种方式，这也是nginx性能高效的主要原因。 我们之前说过，推荐设置 worker 的个数为 cpu 的核数，在这里就很容易理解了，更多的 worker 数，只会导致进程来竞争 cpu 资源了，从而带来不必要的上下文切换。而且，nginx为了更好的利用多核特性，提供了 cpu 亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来 cache 的失效。像这种小的优化在 Nginx 中非常常见，同时也说明了 Nginx 作者的苦心孤诣。比如，Nginx 在做 4 个字节的字符串比较时，会将 4 个字符转换成一个 int 型，再作比较，以减少 cpu 的指令数等等。 现在，知道了 Nginx 为什么会选择这样的进程模型与事件模型了。对于一个基本的 Web 服务器来说，事件通常有三种类型，网络事件、信号、定时器。从上面的讲解中知道，网络事件通过异步非阻塞可以很好的解决掉。如何处理信号与定时器？ 首先，信号的处理。对 Nginx 来说，有一些特定的信号，代表着特定的意义。信号会中断掉程序当前的运行，在改变状态后，继续执行。如果是系统调用，则可能会导致系统调用的失败，需要重入。关于信号的处理，大家可以学习一些专业书籍，这里不多说。对于 Nginx 来说，如果nginx正在等待事件（epoll_wait 时），如果程序收到信号，在信号处理函数处理完后，epoll_wait 会返回错误，然后程序可再次进入 epoll_wait 调用。 另外，再来看看定时器。由于 epoll_wait 等函数在调用的时候是可以设置一个超时时间的，所以 Nginx 借助这个超时时间来实现定时器。nginx里面的定时器事件是放在一颗维护定时器的红黑树里面，每次在进入 epoll_wait前，先从该红黑树里面拿到所有定时器事件的最小时间，在计算出 epoll_wait 的超时时间后进入 epoll_wait。所以，当没有事件产生，也没有中断信号时，epoll_wait 会超时，也就是说，定时器事件到了。这时，nginx会检查所有的超时事件，将他们的状态设置为超时，然后再去处理网络事件。由此可以看出，当我们写 Nginx 代码时，在处理网络事件的回调函数时，通常做的第一个事情就是判断超时，然后再去处理网络事件。 我们可以用一段伪代码来总结一下 Nginx 的事件处理模型： 12345678910111213141516171819202122while (true) &#123; for t in run_tasks: t.handler(); update_time(&amp;now); timeout = ETERNITY; for t in wait_tasks: /* sorted already */ if (t.time &lt;= now) &#123; t.timeout_handler(); &#125; else &#123; timeout = t.time - now; break; &#125; nevents = poll_function(events, timeout); for i in nevents: task t; if (events[i].type == READ) &#123; t.handler = read_handler; &#125; else &#123; /* events[i].type == WRITE */ t.handler = write_handler; &#125; run_tasks_add(t);&#125;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"关于安装zookeeper集群","slug":"关于安装zookeeper集群","date":"2021-08-03T00:53:33.000Z","updated":"2021-08-03T02:15:41.081Z","comments":true,"path":"2021/08/03/关于安装zookeeper集群/","link":"","permalink":"http://example.com/2021/08/03/%E5%85%B3%E4%BA%8E%E5%AE%89%E8%A3%85zookeeper%E9%9B%86%E7%BE%A4/","excerpt":"","text":"开始安装配置zookeeper1、远程下载zookeeper 有时候jdk版本和zookeeper版本不兼容，会导致zookeeper运行不成功，我的jdk是1.8 下载zookeeper链接如下： 1[root@localhost src]# wegt https://downloads.apache.org/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz 2、解压 1[root@localhost src]# tar -xvf apache-zookeeper-3.7.0-bin.tar.gz 3、配置，进行conf文件夹，把zoo_sample.cfg文件改名为zoo.cfg，因为zookeeper默认加载的配置文件名是zoo.cfg 1[root@localhost conf]# mv zoo_sample.cfg zoo.cfg 4、打开zoo.cfg文件，修改数据与日志存放目录，其中dataDir与dataLogDir对应的目录要先创建 5、配置etc/profile文件，在文件后台添加zookeeper安装的目录，保存后source /etc/profile zookeeper命令，进入zookeeper安装目录的bin文件夹1、启动zookeeper后台服务：zkServer.sh start 2、关闭zookeeper后台服务：zkServer.sh stop 3、查看zookeeper后台服务运行状态：zkServer.sh status 4、zkCli.sh是zookeeper客户端相关操作","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Redhat8安装配置Nginx","slug":"Redhat8安装配置Nginx","date":"2021-08-02T07:45:34.000Z","updated":"2021-08-02T08:01:17.593Z","comments":true,"path":"2021/08/02/Redhat8安装配置Nginx/","link":"","permalink":"http://example.com/2021/08/02/Redhat8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AENginx/","excerpt":"","text":"Redhat-8安装NginxNginx 安装系统平台：Red Hat Enterprise Linux 8 64位。 一、安装编译工具及库文件1yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 安装完成后终端显示如下： 二、首先要安装 PCREPCRE 作用是让 Nginx 支持 Rewrite 功能。 1、下载 PCRE 安装包，下载地址： http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz 12[root@localhost src]# cd /usr/local/src/[root@localhost src]# wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz 安装完成后显示如下： 2、解压安装包: 1[root@localhost src]# tar zxvf pcre-8.35.tar.gz 3、进入安装包目录 1[root@localhost src]# cd pcre-8.35 4、编译安装 12[root@localhost pcre-8.35]# ./configure[root@localhost pcre-8.35]# make &amp;&amp; make install 5、查看pcre版本 1[root@localhost pcre-8.35]# pcre-config --version 安装 Nginx1、下载 Nginx，下载地址：https://nginx.org/en/download.html 12[root@localhost src]# cd /usr/local/src/[root@localhost src]# wget http://nginx.org/download/nginx-1.18.0.tar.gz 2、安装包 1[root@localhost src]# tar zxvf nginx-1.18.0.tar.gz 3、进入安装包目录 1[root@localhost src]# cd nginx-1.18.0 4、编译安装 1[root@localhost nginx-1.18.0]# ./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35[root@localhost nginx-1.18.0]# make[root@localhost nginx-1.18.0]# make install 5、查看nginx版本 1[root@bogon nginx-1.18.0]# /usr/local/webserver/nginx/sbin/nginx -v nginx安装完成 Nginx 配置进入conf路径并创建 Nginx 运行使用的用户 ：Faker 1[root@localhost src]# cd /usr/local/webserver/nginx/conf 1[root@localhost conf]# /usr/sbin/groupadd Faker[root@localhost conf]# /usr/sbin/useradd -g Faker Faker 配置nginx.conf ，将/usr/local/webserver/nginx/conf/nginx.conf替换为以下内容: 1[root@localhost conf]# cat /usr/local/webserver/nginx/conf/nginx.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374user Faker Faker;worker_processes 1; #设置值和CPU核心数一致error_log /usr/local/webserver/nginx/logs/nginx_error.log crit; #日志位置和日志级别pid /usr/local/webserver/nginx/nginx.pid;#Specifies the value for maximum file descriptors that can be opened by this process.worker_rlimit_nofile 65535;events&#123; use epoll; worker_connections 65535;&#125;http&#123; include mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;; #charset gb2312; server_names_hash_bucket_size 128; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 8m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml; gzip_vary on; #limit_zone crawler $binary_remote_addr 10m; #下面是server虚拟主机的配置 server &#123; listen 80;#监听端口 server_name localhost;#域名 index index.html index.htm index.php; root /usr/local/webserver/nginx/html;#站点目录 location ~ .*\\.(php|php5)?$ &#123; #fastcgi_pass unix:/tmp/php-cgi.sock; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|ico)$ &#123; expires 30d; # access_log off; &#125; location ~ .*\\.(js|css)?$ &#123; expires 15d; # access_log off; &#125; access_log off; &#125;&#125; 检查配置文件nginx.conf的正确性命令： 1[root@localhost conf]# /usr/local/webserver/nginx/sbin/nginx -t 启动 NginxNginx 启动命令如下： 1[root@localhost conf]# /usr/local/webserver/nginx/sbin/nginx 在网站输入本地ip地址进行访问 大功告成！","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"关于命令行窗口无法运行pip命令","slug":"关于命令行窗口无法运行pip命令","date":"2021-08-02T02:05:07.000Z","updated":"2021-08-02T02:14:59.879Z","comments":true,"path":"2021/08/02/关于命令行窗口无法运行pip命令/","link":"","permalink":"http://example.com/2021/08/02/%E5%85%B3%E4%BA%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8Cpip%E5%91%BD%E4%BB%A4/","excerpt":"","text":"关于电脑终端无法运行pip命令 在终端输入pip命令以后显示为 12&gt;pip&#x27; 不是内部或外部命令，也不是可运行的程序&gt;或批处理文件。 考虑到是python环境变量的设置问题，故进入系统环境变量进行查看 发现环境变量并没有配置python的Path，故进入磁盘查找python的安装位置，将其路径配置到环境变量中。 配置完python环境变量以后进入命令行窗口进行查看，输入pip –versiong 若有如下显示则为配置成功。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"集合框架区别","slug":"集合框架区别","date":"2021-07-31T00:46:48.000Z","updated":"2021-07-31T01:08:44.002Z","comments":true,"path":"2021/07/31/集合框架区别/","link":"","permalink":"http://example.com/2021/07/31/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%8C%BA%E5%88%AB/","excerpt":"","text":"集合框架HashMap和HashTable的区别 ​ 1.HashMap是HashTable的轻量级实现（即非线程安全的实现），他们都完成了Map接口，主要区别来自于HashMap允许空（null）键和空（null）值，由于非线程安全，在效率上可能高于HashTable。 ​ 2.HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 ​ 3.HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 ​ 4.Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 ​ 5.Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 ArrayList和LinkedList区别 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据 List和Set区别 两个接口都是继承自Collection，是常用来存放数据项的集合，主要区别如下： List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在。 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合。 List可以通过下标来访问，而Set不能。 HashSet和HashMap区别 HashSet的底层是HashMap HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 ArrayList和HashSet区别 1.HashSet 是不重复的 而且是无序的! ​ 唯一性保证. 重复对象equals方法返回为true ，重复对象hashCode方法返回相同的整数 ​ HashSet其实就是一个HashMap,只是你只能通过Set接口操作这个HashMap的key部分, 2.ArrayList是可重复的 有序的 ​ 特点：查询效率高，增删效率低 轻量级 线程不安全。 arraylist：在数据的插入和删除方面速度不佳，但是在随意提取方面较快 HashSet和TreeSet区别 一、HashSet HashSet内部的数据结构是哈希表，是线程不安全的。 HashSet当中，保证集合中元素是唯一的方法。 通过对象的hashCode和equals方法来完成对象唯一性的判断。 假如，对象的hashCode值是一样的，那么就要用equals方法进行比较。 假如，结果是true，那么就要视作相同元素，不存。 假如，结果是false，那么就视为不同元素，存储。 注意了，假如，元素要存储到HashCode当中，那么就一定要覆盖hashCode方法以及equals方法。 二、TreeSet TreeSet能够对Set集合当中的元素进行排序，是线程不安全的。 TreeSet当中，判断元素唯一性的方法是依据比较方法的返回结果是否为0，假如是0，那么是相同的元素，不存，假如不是0，那么就是不同的元素，存储。 TreeSet对元素进行排序的方式： 1、元素自身具备比较功能，也就是自然排序，需要实现Comparable接口，并覆盖其compareTo方法。 2、元素自身不具备比较功能，那么就要实现Comparator接口，并覆盖其compare方法。 除此之外，还要注意了，LinkedHashSet是一种有序的Set集合。 也就是其元素的存入和输出的顺序是相同的。 HashMap和TreeMap区别 HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。 另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。 HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。 TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。 ArrayList和Vector区别 Vector是线程安全的，ArrayList不是线程安全的。 ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。 Array和ArrayList区别 1.Array可以存基本数据类型和对象，ArrayList只能存对象。 2.Array没有ArrayList内置的方法多。 3.Array是指定固定大小的，而ArrayList可以自动进行扩容操作。 Iterator和Listiterator区别 1.Iterator可以遍历set和List集合，而Listiterator只能遍历List集合。 2.Iterator只能单向遍历，而Listiterator可以实现双向遍历。 3.ListIterator从Iterator接口继承并实现来额外的一些功能方法。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"JAVA学习基础(一)","slug":"JAVA学习基础一","date":"2021-07-16T06:41:52.000Z","updated":"2021-07-31T00:44:08.630Z","comments":true,"path":"2021/07/16/JAVA学习基础一/","link":"","permalink":"http://example.com/2021/07/16/JAVA%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B8%80/","excerpt":"","text":"变量的定义和使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package student.aistar.day01;/* *@Auther Zhourui *@data 2021/7/16 18:58 *@Email 1605576647@qq.com */public class VarInitDemo &#123; public static void main(String[] args) &#123; byte b = 127; short s = 100;//使用频率很少 //开发中常用的整数型类型 - int,long //int类型可以初始化的值有哪些 int a = 100; //存储一个二进制,只要0b二进制,1010对应的十进制 //java中的int类型表示的是十进制的数据 //1010 = 1*2^3+1+2^1 = 10 int a1 = 0b1010; System.out.println(a1); //java中使用单引号来表示一个字符 //&#x27;a&#x27;-&gt;char类型-&gt;int类型 //&#x27;a&#x27;对应的ascii码97 //&#x27;A&#x27;对应的ascii码是65 //&#x27;0&#x27;对应的ascii码是48 int a2 = &#x27;a&#x27;; System.out.println(a2); //java中以0开头的代表是八进制 //八进制转换十进制032 = 3*8^1 + 2*8^0 = 26 int a3 = 032; System.out.println(a3);//26 //长整型 - long //int类型-&gt;long类型 long x1 = 100; //推荐定义long的方式采用隐式转换 long x2 = 200L; //jdk7.x提供的 - 为了增强数字的可读性而已. long x3 = 3_14_15_926L; System.out.println(x3);// Date date = new Date(3L*24*60*60*100*1000*1000*2000);// System.out.println(date); //浮点数 - 并不是用来进行精确计算的 //后面java.math.Decimal类解决小数计算的时候精度丢失的问题. double d = 1.75; //推荐定义double double d2 = 5.67D; //float的精度是7或者8 //double的精度是16 //double类型强制转换成float类型 float f = (float) 3.14; //隐式转换 float f2 = 3.14F; System.out.println(f2); //补充 //数字进行计算的时候,都会转换成二进制进行计算 //小数进行计算的时候,还是不可逆的 //0.8999999999999999 System.out.println(2.0-1.1); //0.9 System.out.println(2.0f - 1.1f); //int-&gt;float × //int-&gt;double √ int n = 123456789; float ft = n; System.out.println(ft);//1.23456792E8 double db = n; System.out.println(db);//1.23456789E8 float f3 = 1.234567565f; System.out.println(f3);//1.2345675 //定义布尔类型 boolean flag = true; System.out.println(flag); //最特殊的是char类型 char c = 65; System.out.println(c); &#125;&#125; 注：char类型java中是使用单引号表示char类型,使用双引号来表示字符串. java的底层的编码是unicode编码,char类型也是采用unicode编码 unicode编码是双字节[16bit],所以存储一个汉字. ascii码和unicode码的关系? 不同的国家,符号表示的方式不同,所以ascii码[0127]不够用.所以unicode[065535]码诞生了,几乎 包含了所有国家的符号,unicode码包含ascii码.char类型在进行计算的时候会转换成ascii码来进行计算. 代码部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package student.aistar.day01;/* *@Auther Zhourui *@data 2021/7/16 19:27 *@Email 1605576647@qq.com */public class CharDemo &#123; public static void main(String[] args) &#123; //java中是使用单引号表示char类型 //char的空间大小也是确定的 char c = &#x27;a&#x27;; System.out.println(c); //十六进制 //由数字0-9或者字母a-f/A-F,字母a代表就是数字10 //cmd - 输入native2ascii -&gt; 输入中文 char c2 = &#x27;\\u34af&#x27;; System.out.println(c2); //char底层采用的是unicode编码,所以存储一个汉字 char c3 = &#x27;星&#x27;; System.out.println(c3); char c4 = 48; System.out.println(c4); int m = 48; char c5 = (char) m; System.out.println(c5); //char类型在进行计算的时候会转换成ascii码来进行计算. //&#x27;a&#x27; = 97,&#x27;A&#x27; = 65,&#x27;0&#x27; = 48 //char类型的计算 - 进阶部分 char n1 = &#x27;a&#x27; + 1;//ok System.out.println(n1);// &#x27;b&#x27; char cc = &#x27;a&#x27;; char nn = (char) (cc + 1); System.out.println(cc); //char-&gt;int int result = &#x27;a&#x27; + &#x27;b&#x27;;//ok System.out.println(result);//195 &#125;&#125; 变量的赋值方式 单个赋值 int a = 10; 通过表达式赋值 1234int a = 10;int b = 20;//表达式:由字面量或者变量以及运算符号组成的合法的语句int result = a + b; 链式赋值 123int a=10,b=20,c=30;//同时声明了三个变量,并且都进行初始化int a,b,c = 100;//此处仅仅是对c进行赋值操作,如果一个局部变量没有进行赋值,那么将不能够使用 可以先定义变量,然后再进行赋值 1234int a;a = 10;a = 20;System.out.println(a); 通过方法进行赋值 - 暂时了解 12345678910int result = getResult(); /** * 自定义了一个方法 - 千万不要将它放在main方法中 * java语法 - 方法体内部是不能够再去定义方法的 * @return 整数 */public static int getResult()&#123; return 100;&#125; 变量的分类 局部变量 - 定义在方法体内部 使用的范围就是在它所在的最近的那个{}中 全局变量 - 定义在方法体外部的变量 生命周期 - 面向对象 常量 使用final修饰的变量 - 常量 - 不可改变的量 语法 1final 数据类型 变量 [=初始值] 1234567891011121314151617181920212223242526272829303132333435363738394041package student.aistar.day01;/* *@Auther Zhourui *@data 2021/7/16 19:11 *@Email 1605576647@qq.com */public class LocalVarAndGlobalDemo &#123; //定义全部变量 static int c = 100;//静态变量 - 暂不了解 public static void main(String[] args) &#123; //代码块 //局部变量 - 定义在方法体内部 int a= 10; &#123;// 使用的范围就是在它所在的最近的那个&#123;&#125;中 int b = 20; System.out.println(a);//ok System.out.println(b);//ok &#125; //使用的范围就是在它所在的最近的那个&#123;&#125;中 //System.out.println(b);//error //访问全局变量 System.out.println(c); //定义一个常量 - 不可改变的量 final int s = 100; //s = 200; //final - b肯定不可变 final byte b = 100; byte result = b + 1;//ok &#125;&#125; 运算符算术运算符12345678910111213141516171819201. + java语言中唯一重载[具有多个意义]的运算符 数值之间表示的加法运算,如果出现了&quot;字符串&quot;,表示拼接[后面就会知道拼接效率很低] 2. - 减法 * 乘法 3. / 除法[配合计算过程中需要注意的结果的类型而已] - 取整 4. % 取余/模 /和%结合使用,可以获取某个数字任意位上的数值. 5. += -= *= /= %= 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 6. ++和-- 前++/后++ - 变量本身都会自增1 前--/后-- - 变量本身都会自减1 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 比较运算符12&gt; &lt;= &gt;= &lt; !=比较得到的结果是一个boolean类型即可 逻辑运算符 &amp;&amp; - 逻辑与,短路与.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 所有的条件表达式都是返回true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为false的放在最左边 - 提高代码的执行效率. || - 逻辑或,短路或.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 只要有一个表达式是true,那么结果就是true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为true的放在最左边 - 提高代码的执行效率. ! - 逻辑非,true成为false,false成为true 位运算符 &amp; - 按位&amp;,非短路与,最主要的作用就是用来计算的,但是可以用来连接条件表达式. ​ 计算:都是1,结果才是1.只要出现1个0,那么结果就是0 ​ 连接条件:为true - 所有的条件表达式都是返回true 1234567891011121310 &amp; 8 = 8 十进制的数不断除以2,直到商为0,然后倒过来取余数 - 101010 / 2 = 商5......余05 / 2 = 商2 ...... 12/ 2 = 1 ........ 01/2 = 0 .........1 1 0 1 0 &amp; 1 0 0 0------------------ 1 0 0 0 -&gt; 对应的十进制8 | - 按位或,非短路或,最主要的作用就是用来计算的,但是可以用来连接条件表达式. 计算:只要存在一个1,结果就是1 连接条件:为true - 只要存在一个条件表达式为true. 123456710 | 8 = ? 1 0 1 0| 1 0 0 0------------------ 1 0 1 0 -&gt; 对应的十进制10 异或^ 作用:进行计算的 - 相同为0,不同为1 12345610 ^ 8 = 2 1 0 1 0 | 1 0 0 0------------------ 0 0 1 0 -&gt; 2 10 ^ 8 ^ 8 = 10 12340 0 1 0 1 0 0 0----------------- 1 0 1 0 -&gt; 10 结论:一个数字连续异或同一个数字俩次结果是它本身. 可以进行加密和解密的操作 注：1234567891011121314151617181920212223package student.aistar.day01;/* *@Auther Zhourui *@data 2021/7/16 19:20 *@Email 1605576647@qq.com */public class ChangeVarValue &#123; public static void main(String[] args) &#123; //使用第三方变量 int a=3,b=4,temp; temp=a; a=b; b=temp; System.out.println(&quot;a:&quot; + a); System.out.println(&quot;b:&quot; + b); //不使用第三方变量 int x=100,y=200; x=x^y; y=x^y; x=x^y; System.out.println(&quot;x:&quot; + x); System.out.println(&quot;y:&quot; + y);&#125; &#125; 取反~,1变0,0变成1 补码 - 负数在计算机中的表现形式就是以补码的形式存在的 123456789101112131415161718192021222324252627282930补码 = 反码 + 1;反码 = 原码符号位不变,其余位依次取反符号位 - 最高位代表的是符号位.1代表的是负数,0代表的是正数.反码本身没有意义的,它的存在就是为了计算补码正数的补码,反码,原码都是它本身.计算一下:-10的二进制是多少?-10的补码是多少?计算步骤:1. -10原码 10000000 00000000 00000000 000010102. -10的反码 10000000 00000000 00000000 00001010 11111111 11111111 11111111 111101013. -10的补码 = 反码+1 11111111 11111111 11111111 11110101 + 1 ------------------------------------- 11111111 11111111 11111111 11110110 -&gt; -10的二进制计算~900000000 00000000 00000000 0000100111111111 11111111 11111111 11110110 -&gt; ~9取反的结果-10 = ~9结论:-(x+1) = ~x 移位操作 笔试题 - 计算性能最高的操作,jdk源码里面很多都是移位操作 1234567891011121314151617181920&lt;&lt; 向左移动2&lt;&lt;2 =&gt; 0010 &lt;&lt; 2 = 1000 = 8原题:请你用最高性能的方式计算出2的3次方.&gt;&gt; 带符号的右移动,向右移动多少位,那么就在最高位补符号位-10 &gt;&gt; 2 = -311111111 11111111 11111111 11110110 &gt;&gt; 211111111 11111111 11111111 11111101 -&gt; 负数的二进制,最高位是100000000 00000000 00000000 00000010 取反 ~2=-3&gt;&gt;&gt; 不带符号的右移动,向右移动多少位,就在最高位补0 -10 &gt;&gt;&gt; 2 10000000 00000000 00000000 00001010 11111111 11111111 11111111 11110110 &gt;&gt; 2 00111111 11111111 11111111 11111101 -&gt; 计算出十进制 01000000 00000000 00000000 00000000 - 3----------------------------------------- 1073741821 方法 - Method 非常重要,如果没有跟上,直接出局. 相当于其他语言中函数function,功能是用来封装代码的逻辑. 把一段代码封装到方法中,方便以后复用,提高了代码的可维护性. 语法1234修饰符 返回类型 方法名([参数列表]) [throws 可抛出的异常列表]&#123;..方法体...&#125;现阶段:修饰符 返回类型 方法名([参数列表])&#123;..方法体...&#125; 修饰符访问修饰符 作用:就是决定了这个方法可以被调用的范围. public - 公开的,公共的.如果一个方法被public进行了修饰,那么代表这个方法可以在别的地方被调用. private - 私有的,只能在当前类内部被调用 - 体现了”封装性” - 不对外公开的. 默认的 受保护的 特殊修饰符[超纲的内容] static - 静态的 如果使用static修饰的方法 - 静态方法 如果没有使用static修饰的方法 - 非静态方法 是否为静态的方法决定了这个方法被调用的方式. 返回类型 有返回类型 可以是八种基本数据类型,也可以是对象类型[内置对象类型或者自定义对象类型] 方法体的最终的出口一定有return 返回值. 12345678return 作用1 - 返回方法最终的执行结果 作用2 - 用来结束整个方法正常情况方法的返回类型是什么,返回值的结果的类型也应该是什么非正常情况 - 支持类型的自动转换和强制类型转换的.调用的时候 - 需要使用数据类型和变量来接受这个方法调用的结果. 方法的返回类型是什么,就用什么类型去定义.当然也是支持类型的转换 无返回类型 - void 1不需要使用return + 返回值; 该如何选择? 如果某个方法的执行结果可能在另外一个地方被使用到,那么一定要定义成有返回类型 如果一个方法仅仅是为了输出,只要定义void 12public static int test01(int m,int n)&#123; //code... return m和n的最大公约数 //System.out.println(公约数) } //int m = test01(20,12);//m-&gt;4 public static int test02(int m,int n){ int 公约数 = test01(m,n); return mn/公约数; } int n = test02(20,12);//n-&gt;60=2012/4=60 1 方法名 参考变量名的命名规则 - 一模一样 标识符 - 给类,包,变量,方法取的名称 参数列表 无参列表 带参列表 可变长列表 该如何定义方法 方法体内部不能够再去定义方法了 main方法仍然是程序的主入口. 自定义的方法希望能够被调用,那么最终肯定是在main方法中进行调用的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package student.aistar.day01;/* *@Auther Zhourui *@data 2021/7/16 19:40 *@Email 1605576647@qq.com */ public class MethodHelloDemo &#123; /** * main - 仍然是程序的主入口 * @param args */ public static void main(String[] args) &#123; //类中的方法 - 类里面的成员 //static - 静态的成员被初始化的时机 //静态方法什么时候被初始化的? - 当JVM加载类进内存的时候,就会立即给所有的静态的成员分配空间以及初始化 //在这个阶段,压根就没有对象的概念,只有类. //结论 - 静态的成员属于类的,并且初始化的时机有且1次. //属于谁,就由谁去调用! //1. 调用静态的方法,直接通过类.方法名([参数]) //类 - 该静态方法所在的当前类 MethodHelloDemo.sub(); //non-static -&gt; 非静态的成员被初始化的时机? //当遇到创建对象的语法.每次创建对象的时候,都会给各自的非静态成员分配空间以及初始化 //如果没有创建对象,就不会初始化这些非静态成员. //结论: 非静态成员是属于对象的.属于谁,由谁调用. //2. 非静态方法 - 通过对象去调用 //调用哪个类中的方法,就去创建哪个类的对象 //后面的OO知识点 -&gt; 类名 变量 = new 类名(); //创建了一个 MethodHelloDemo对象,m就是对象名 MethodHelloDemo m = new MethodHelloDemo(); m.add(); &#125; /** * 定义了公开的非静态的无返回类型的方法 */ public void add()&#123; System.out.println(&quot;add...&quot;); &#125; /** * 定义了公开的静态的无返回类型的方法 */ public static void sub()&#123; System.out.println(&quot;sub...&quot;); &#125;&#125; 注： 静态方法中只能够直接调用静态方法 非静态方法中可以直接调用非静态方法以及静态方法 通用的原则 - 类名.静态方法或者对象.非静态方法 静态方法属于类拥有的,非静态方法属于对象拥有的 静态的方法是jvm加载类进内存的时候就会立即被分配空间以及初始化,并且机会仅仅只有1次. 而非静态方法必须是等到创建对象的时候,才会被分配空间以及初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package student.aistar.day01;/* *@Auther Zhourui *@data 2021/7/16 19:44 *@Email 1605576647@qq.com */public class StaticDetailDemo &#123; //定义了全局变量 //属性,方法 =&gt; 成员 //非静态的属性 int n = 10;//等创建对象的时候,才会分配空间和初始化 //静态属性-初始化的时机优先于静态方法 static int m = 100; public static void main(String[] args) &#123; //此时n还未初始化 //System.out.println(n);//编译错误 //System.out.println(m); //调用test03 - 非静态的 StaticDetailDemo s = new StaticDetailDemo(); s.test03(); System.out.println(s); &#125; //非静态的 public void test01()&#123; System.out.println(&quot;test01..&quot;); &#125; //静态的 public static void test02()&#123; int n = 10; System.out.println(&quot;test02...&quot;); //自定义的方法中是可以调用自己自定义的方法的 //1. 另外一个静态方法test04 StaticDetailDemo.test04(); //静态方法中可以直接调用静态方法 test04(); //2. 另外一个非静态方法test03 StaticDetailDemo s1 = new StaticDetailDemo(); s1.test03(); &#125; public void test03()&#123; //static int n = 20;//非静态方法中不允许定义静态的局部变量 System.out.println(&quot;test03..&quot;); //非静态方法中调用静态方法 - 类名.方法 //StaticDetailDemo.test04();//ok test04();//ok //非静态方法中直接调用另外一个非静态方法呢??? - 肯定是需要一个对象去调用. test01();//ok //实际上省略了一个关键字this //this代表的是当前对象 //当前对象 - 调用该方法[test03]的对象 //this.test01(); System.out.println(this); &#125; public static void test04()&#123; System.out.println(&quot;test04..&quot;); &#125;&#125; 方法调用补充 方法的调用者和方法的定义者在同一个类中. 方法的调用者和方法的定义者不在同一个类中,但是仍然在同一个package中. 只能使用通用的原则类名.静态方法或者对象.非静态方法 方法的调用者和方法的定义者是存在于不同包下的不同类中. 必须先通过import关键字进行导包操作. 使用jdk中的类的时候,除了java.lang包下的不需要手动import,其余包下的都需要先import 递归算法 - 错误的写法 - 方法内部直接调用自己 private 和 public 该选择使用123456789101112131415161718192021222324252627public class 牛叉的工具类&#123; public static void 牛叉的方法01()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //.. //... &#125; private static void 小的牛叉方法01()&#123; //专门封装了小的功能. &#125; public static void 牛叉的方法02()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //... //... &#125;&#125;","categories":[],"tags":[{"name":"JAVA学习","slug":"JAVA学习","permalink":"http://example.com/tags/JAVA%E5%AD%A6%E4%B9%A0/"}]},{"title":"git_hexo","slug":"hexo+github搭建博客服务器","date":"2021-07-13T07:12:52.000Z","updated":"2021-07-13T07:14:00.567Z","comments":true,"path":"2021/07/13/hexo+github搭建博客服务器/","link":"","permalink":"http://example.com/2021/07/13/hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"hexo+github搭建博客服务器 csdn,简书,有道笔记 - 广告比较多 hexo+github[比较慢,翻墙]/gitee[Git pages服务器 - 维护]/阿里云服务器 安装nodejs 非中文的非特殊字符的目录中[目录中不要出现空格或者带有特殊符号的] D:/node-v14.17.3-win-x64 环境变量的配置 桌面计算机 - 右击 - 属性 - 高级系统设置 - 环境变量(N) 定位到下方的系统变量 定位到变量名 - Path - 编辑 - 新建 D:/node-v14.17.3-win-x64 一定要关闭所有的环境变量配置的窗口 - 确定 打开终端[如果终端已经打开了,关闭 - 重新打开] win[微软图标]+r - 输入cmd - 输入如下指令检测nodejs是否配置成功 12345npm -v6.14.5 出现版本号,则说明配置成功如果出现了不是内部或者外部的命令的同学,请检查自己的nodejs解压缩之后的路径是否成功配置到了path中 简单认识npm npm是javascript的一个**包[前端框架]**管理工具,并且是nodejs平台默认的包管理工具. 通过npm可以安装,共享,分发代码,管理项目依赖关系. 类似于java中的maven或者gradle[强大的项目构建工具以及项目依赖管理工具] npm简单使用修改镜像 为了下载速度变快,修改npm的镜像 1npm config set registry https://registry.npm.taobao.org 验证一下,镜像是否成功修改了 123npm config get registryhttps://registry.npm.taobao.org/ 简单使用 - 不需要操作 下载bootstrap npm install 框架名称 - 默认下载的是最新的版本 1npm install bootstrap@3 Hexo官网 https://hexo.io/zh-cn/docs/ 安装 假设你在D盘根目录下新建了一个文件夹hello-hexo[博客项目的根目录] win+r - 打开终端 通过dos命令进入到hello-hexo目录中 123C:/User/admin&gt;d:D:&gt;cd hello-hexoD:/hello-hexo&gt;npm install hexo-cli -g 创建真正的博客目录1D:/hello-hexo&gt;hexo init hello-blog 12cd hello-blogD:/hello-hexo/hello-blog&gt;npm install 测试 - 启动博客服务器1D:/hello-hexo/hello-blog&gt;hexo s 关闭服务器 1ctrl+c 打开浏览器输入:localhost:4000 常用主题模板 https://blog.csdn.net/zgd826237710/article/details/99671027 使用git命令来进行克隆,需要提前安装好git,检测git是否安装成功,重新打开终端 1git --version 注册码云账号 推荐用QQ注册一下 本地配置码云账号信息 - 配置文件 - 位置windows的用户主目录下 C:/User/计算机用户名 - 观察是否存在**.gitconfig**文件,添加如下内容 1[user] email = 码云的QQ邮箱 name = 用户名 安装模板 通过cmd进入到hello-blog目录中的themes目录中 1D:/hello-hexo/hello-blog&gt;cd themesD://hello-hexo/hello-blog/themes&gt;git clone https://gitee.com/guancg/hexo-theme-pure.git 或者直接从github上直接clone 1git clone https://github.com/cofess/hexo-theme-pure.git 更新主题配置 指定新的主题 hello-blog目录下的_config.yml文件 1theme: hexo-theme-pure 重启服务器hexo s 个人信息hexo-theme-pure/_config.yml文件 1overriden author: 亲爱的管管 author_title: 高级打字员 author_description: 个人简介。 location: SuZhou, China Markdown语法 语法的编辑器 - https://typora.io/ 文件的后缀是md 1常用语法如下:1. 标题的语法:1~6标题 - # 一级标题 ## 二级标题 2. 代码块 - java,js,mysql...​~~~java 敲enter键3. 列表3-1. 无序列表 * 列表名称 有序列表 1. 列表名称4. 高亮显示 `高亮显示内容`5. 加粗字体 **粗体**6. 斜体 *斜体*7. 粗+斜 ***粗斜***8. 段落 &gt; 空格9. 引入外部图片 ![](xx.png)10. 表格 新建博文1D://hello-hexo/hello-blog&gt;hexo n java 效果:hello-blog目录下的source/_ports/自动生成一个java.md文件 重启blog服务器 1D://hello-hexo/hello-blog&gt;hexo s 主题的侧边栏 侧边栏的链接生效 将/hello-blog/themes/hexo-theme-pure/_source/下的除了_data文件夹,其余文件夹 拷贝一份放入到hello-blog目录下的source目录中即可 文章的分类和标签 只需要在文章的.md文件的自动生成的头部添加 1title: javadate: 2021-07-13 08:44:42categories: javatags: java 博客的语言环境设置 设置中文 hello-blog下的_config.yml文件中 language: zh-CN 图片显示问题 安装插件 - npm install https://gitee.com/guancg/hexo-asset-image.git –save 需要到hello-blog/_config.yml文件中进行配置 1post_asset_folder: true hexo n 机器学习 效果就是除了生成了机器学习.md还有一个机器学习文件夹,那么这篇文章的所有的图片就可以存储在机器学习文件夹中 hexo s 内置搜索的功能 1# Searchsearch:insight: true # you need to install `hexo-generator-json-content` before using Insight Searchbaidu: false # you need to disable other search engines to use Baidu search 安装内置搜索插件 npm i -S hexo-generator-json-content 评论 不需要本地数据库进行存储的,用的是第三方的. LeanCloud - 官网地址 - https://www.leancloud.cn/ 注册 - 登录 - 控制台 - 创建应用 - 右下设置 - 应用凭证 appId - sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz appKey - 3hn4ijEgSzJeRV4nkmXThmGV 在hexo-theme-pure\\_config.yml文件中配置 1valine: # Valine. https://valine.js.org appid: sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz # your leancloud application appid appkey: 3hn4ijEgSzJeRV4nkmXThmGV# your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style meta: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true # Article reading statistic https://valine.js.org/visitor.html #字数统计&amp;阅读时长 npm i -S hexo-wordcount hexo-theme-pure_config.yml文件中配置 1postCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 附件-优秀插件 显示图片 1npm install https://gitee.com/guancg/hexo-asset-image.git --save 内置搜索 1npm i -S hexo-generator-json-content 字数统计&amp;阅读时长 1npm i -S hexo-wordcount github部署 1npm install hexo-deployer-git --save github注册一下 github.com chrome浏览器 + iguge - https://iguge.app/ 新建的仓库的名称必须是guancgsuccess.github.io 仓库地址 - https://github.com/guancgsuccess/guancgsuccess.github.io.git 安装github部署插件 npm install hexo-deployer-git –save hello-blog/_config.yml文件 1deploy:type: &#x27;git&#x27;repo: &#x27;https://github.com/guancgsuccess/guancgsuccess.github.io.git&#x27;branch: &#x27;master&#x27; hexo三连操作 1hexo clhexo ghexo shexo d 浏览器输入 - guancgsuccess.github.io","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"喵喵","slug":"喵喵","date":"2021-07-13T02:05:09.000Z","updated":"2021-07-13T02:08:14.877Z","comments":true,"path":"2021/07/13/喵喵/","link":"","permalink":"http://example.com/2021/07/13/%E5%96%B5%E5%96%B5/","excerpt":"","text":"我是一只喵喵","categories":[{"name":"喵喵","slug":"喵喵","permalink":"http://example.com/categories/%E5%96%B5%E5%96%B5/"}],"tags":[{"name":"喵喵","slug":"喵喵","permalink":"http://example.com/tags/%E5%96%B5%E5%96%B5/"}]},{"title":"测试","slug":"测试","date":"2021-07-13T01:08:51.000Z","updated":"2021-08-04T08:56:31.471Z","comments":true,"path":"2021/07/13/测试/","link":"","permalink":"http://example.com/2021/07/13/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"测试第一期 1234567891011121314151617public class Singleton &#123; private volatile static Singleton uniqueSingleton; private Singleton() &#123; &#125; public Singleton getInstance() &#123; if (null == uniqueSingleton) &#123; synchronized (Singleton.class) &#123; if (null == uniqueSingleton) &#123; uniqueSingleton = new Singleton(); &#125; &#125; &#125; return uniqueSingleton; &#125;&#125;","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-12T06:45:08.218Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2021/07/12/hello-world/","link":"","permalink":"http://example.com/2021/07/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"喵喵","slug":"喵喵","permalink":"http://example.com/categories/%E5%96%B5%E5%96%B5/"},{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JAVA学习","slug":"JAVA学习","permalink":"http://example.com/tags/JAVA%E5%AD%A6%E4%B9%A0/"},{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"},{"name":"喵喵","slug":"喵喵","permalink":"http://example.com/tags/%E5%96%B5%E5%96%B5/"},{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]}