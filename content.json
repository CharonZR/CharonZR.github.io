{"meta":{"title":"CharonZR","subtitle":"","description":"","author":"ZhouRui","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-15T11:01:42.894Z","updated":"2021-07-15T11:01:42.894Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":"123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"书单","date":"2021-07-12T08:00:15.214Z","updated":"2021-07-12T08:00:15.214Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-12T08:00:15.213Z","updated":"2021-07-12T08:00:15.213Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2021-07-12T08:00:15.214Z","updated":"2021-07-12T08:00:15.214Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-12T08:00:15.215Z","updated":"2021-07-12T08:00:15.215Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-12T08:00:15.216Z","updated":"2021-07-12T08:00:15.216Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-12T08:00:15.215Z","updated":"2021-07-12T08:00:15.215Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"关于命令行窗口无法运行pip命令","slug":"关于命令行窗口无法运行pip命令","date":"2021-08-02T02:05:07.000Z","updated":"2021-08-02T02:14:59.879Z","comments":true,"path":"2021/08/02/关于命令行窗口无法运行pip命令/","link":"","permalink":"http://example.com/2021/08/02/%E5%85%B3%E4%BA%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8Cpip%E5%91%BD%E4%BB%A4/","excerpt":"","text":"关于电脑终端无法运行pip命令 在终端输入pip命令以后显示为 12&gt;pip&#x27; 不是内部或外部命令，也不是可运行的程序&gt;或批处理文件。 考虑到是python环境变量的设置问题，故进入系统环境变量进行查看 发现环境变量并没有配置python的Path，故进入磁盘查找python的安装位置，将其路径配置到环境变量中。 配置完python环境变量以后进入命令行窗口进行查看，输入pip –versiong 若有如下显示则为配置成功。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"集合框架区别","slug":"集合框架区别","date":"2021-07-31T00:46:48.000Z","updated":"2021-07-31T01:08:44.002Z","comments":true,"path":"2021/07/31/集合框架区别/","link":"","permalink":"http://example.com/2021/07/31/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%8C%BA%E5%88%AB/","excerpt":"","text":"集合框架HashMap和HashTable的区别 ​ 1.HashMap是HashTable的轻量级实现（即非线程安全的实现），他们都完成了Map接口，主要区别来自于HashMap允许空（null）键和空（null）值，由于非线程安全，在效率上可能高于HashTable。 ​ 2.HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 ​ 3.HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 ​ 4.Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 ​ 5.Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 ArrayList和LinkedList区别 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据 List和Set区别 两个接口都是继承自Collection，是常用来存放数据项的集合，主要区别如下： List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在。 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合。 List可以通过下标来访问，而Set不能。 HashSet和HashMap区别 HashSet的底层是HashMap HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 ArrayList和HashSet区别 1.HashSet 是不重复的 而且是无序的! ​ 唯一性保证. 重复对象equals方法返回为true ，重复对象hashCode方法返回相同的整数 ​ HashSet其实就是一个HashMap,只是你只能通过Set接口操作这个HashMap的key部分, 2.ArrayList是可重复的 有序的 ​ 特点：查询效率高，增删效率低 轻量级 线程不安全。 arraylist：在数据的插入和删除方面速度不佳，但是在随意提取方面较快 HashSet和TreeSet区别 一、HashSet HashSet内部的数据结构是哈希表，是线程不安全的。 HashSet当中，保证集合中元素是唯一的方法。 通过对象的hashCode和equals方法来完成对象唯一性的判断。 假如，对象的hashCode值是一样的，那么就要用equals方法进行比较。 假如，结果是true，那么就要视作相同元素，不存。 假如，结果是false，那么就视为不同元素，存储。 注意了，假如，元素要存储到HashCode当中，那么就一定要覆盖hashCode方法以及equals方法。 二、TreeSet TreeSet能够对Set集合当中的元素进行排序，是线程不安全的。 TreeSet当中，判断元素唯一性的方法是依据比较方法的返回结果是否为0，假如是0，那么是相同的元素，不存，假如不是0，那么就是不同的元素，存储。 TreeSet对元素进行排序的方式： 1、元素自身具备比较功能，也就是自然排序，需要实现Comparable接口，并覆盖其compareTo方法。 2、元素自身不具备比较功能，那么就要实现Comparator接口，并覆盖其compare方法。 除此之外，还要注意了，LinkedHashSet是一种有序的Set集合。 也就是其元素的存入和输出的顺序是相同的。 HashMap和TreeMap区别 HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。 另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。 HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。 TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。 ArrayList和Vector区别 Vector是线程安全的，ArrayList不是线程安全的。 ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。 Array和ArrayList区别 1.Array可以存基本数据类型和对象，ArrayList只能存对象。 2.Array没有ArrayList内置的方法多。 3.Array是指定固定大小的，而ArrayList可以自动进行扩容操作。 Iterator和Listiterator区别 1.Iterator可以遍历set和List集合，而Listiterator只能遍历List集合。 2.Iterator只能单向遍历，而Listiterator可以实现双向遍历。 3.ListIterator从Iterator接口继承并实现来额外的一些功能方法。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"JAVA学习基础(一)","slug":"JAVA学习基础一","date":"2021-07-16T06:41:52.000Z","updated":"2021-07-31T00:44:08.630Z","comments":true,"path":"2021/07/16/JAVA学习基础一/","link":"","permalink":"http://example.com/2021/07/16/JAVA%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E4%B8%80/","excerpt":"","text":"变量的定义和使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package student.aistar.day01;/* *@Auther Zhourui *@data 2021/7/16 18:58 *@Email 1605576647@qq.com */public class VarInitDemo &#123; public static void main(String[] args) &#123; byte b = 127; short s = 100;//使用频率很少 //开发中常用的整数型类型 - int,long //int类型可以初始化的值有哪些 int a = 100; //存储一个二进制,只要0b二进制,1010对应的十进制 //java中的int类型表示的是十进制的数据 //1010 = 1*2^3+1+2^1 = 10 int a1 = 0b1010; System.out.println(a1); //java中使用单引号来表示一个字符 //&#x27;a&#x27;-&gt;char类型-&gt;int类型 //&#x27;a&#x27;对应的ascii码97 //&#x27;A&#x27;对应的ascii码是65 //&#x27;0&#x27;对应的ascii码是48 int a2 = &#x27;a&#x27;; System.out.println(a2); //java中以0开头的代表是八进制 //八进制转换十进制032 = 3*8^1 + 2*8^0 = 26 int a3 = 032; System.out.println(a3);//26 //长整型 - long //int类型-&gt;long类型 long x1 = 100; //推荐定义long的方式采用隐式转换 long x2 = 200L; //jdk7.x提供的 - 为了增强数字的可读性而已. long x3 = 3_14_15_926L; System.out.println(x3);// Date date = new Date(3L*24*60*60*100*1000*1000*2000);// System.out.println(date); //浮点数 - 并不是用来进行精确计算的 //后面java.math.Decimal类解决小数计算的时候精度丢失的问题. double d = 1.75; //推荐定义double double d2 = 5.67D; //float的精度是7或者8 //double的精度是16 //double类型强制转换成float类型 float f = (float) 3.14; //隐式转换 float f2 = 3.14F; System.out.println(f2); //补充 //数字进行计算的时候,都会转换成二进制进行计算 //小数进行计算的时候,还是不可逆的 //0.8999999999999999 System.out.println(2.0-1.1); //0.9 System.out.println(2.0f - 1.1f); //int-&gt;float × //int-&gt;double √ int n = 123456789; float ft = n; System.out.println(ft);//1.23456792E8 double db = n; System.out.println(db);//1.23456789E8 float f3 = 1.234567565f; System.out.println(f3);//1.2345675 //定义布尔类型 boolean flag = true; System.out.println(flag); //最特殊的是char类型 char c = 65; System.out.println(c); &#125;&#125; 注：char类型java中是使用单引号表示char类型,使用双引号来表示字符串. java的底层的编码是unicode编码,char类型也是采用unicode编码 unicode编码是双字节[16bit],所以存储一个汉字. ascii码和unicode码的关系? 不同的国家,符号表示的方式不同,所以ascii码[0127]不够用.所以unicode[065535]码诞生了,几乎 包含了所有国家的符号,unicode码包含ascii码.char类型在进行计算的时候会转换成ascii码来进行计算. 代码部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package student.aistar.day01;/* *@Auther Zhourui *@data 2021/7/16 19:27 *@Email 1605576647@qq.com */public class CharDemo &#123; public static void main(String[] args) &#123; //java中是使用单引号表示char类型 //char的空间大小也是确定的 char c = &#x27;a&#x27;; System.out.println(c); //十六进制 //由数字0-9或者字母a-f/A-F,字母a代表就是数字10 //cmd - 输入native2ascii -&gt; 输入中文 char c2 = &#x27;\\u34af&#x27;; System.out.println(c2); //char底层采用的是unicode编码,所以存储一个汉字 char c3 = &#x27;星&#x27;; System.out.println(c3); char c4 = 48; System.out.println(c4); int m = 48; char c5 = (char) m; System.out.println(c5); //char类型在进行计算的时候会转换成ascii码来进行计算. //&#x27;a&#x27; = 97,&#x27;A&#x27; = 65,&#x27;0&#x27; = 48 //char类型的计算 - 进阶部分 char n1 = &#x27;a&#x27; + 1;//ok System.out.println(n1);// &#x27;b&#x27; char cc = &#x27;a&#x27;; char nn = (char) (cc + 1); System.out.println(cc); //char-&gt;int int result = &#x27;a&#x27; + &#x27;b&#x27;;//ok System.out.println(result);//195 &#125;&#125; 变量的赋值方式 单个赋值 int a = 10; 通过表达式赋值 1234int a = 10;int b = 20;//表达式:由字面量或者变量以及运算符号组成的合法的语句int result = a + b; 链式赋值 123int a=10,b=20,c=30;//同时声明了三个变量,并且都进行初始化int a,b,c = 100;//此处仅仅是对c进行赋值操作,如果一个局部变量没有进行赋值,那么将不能够使用 可以先定义变量,然后再进行赋值 1234int a;a = 10;a = 20;System.out.println(a); 通过方法进行赋值 - 暂时了解 12345678910int result = getResult(); /** * 自定义了一个方法 - 千万不要将它放在main方法中 * java语法 - 方法体内部是不能够再去定义方法的 * @return 整数 */public static int getResult()&#123; return 100;&#125; 变量的分类 局部变量 - 定义在方法体内部 使用的范围就是在它所在的最近的那个{}中 全局变量 - 定义在方法体外部的变量 生命周期 - 面向对象 常量 使用final修饰的变量 - 常量 - 不可改变的量 语法 1final 数据类型 变量 [=初始值] 1234567891011121314151617181920212223242526272829303132333435363738394041package student.aistar.day01;/* *@Auther Zhourui *@data 2021/7/16 19:11 *@Email 1605576647@qq.com */public class LocalVarAndGlobalDemo &#123; //定义全部变量 static int c = 100;//静态变量 - 暂不了解 public static void main(String[] args) &#123; //代码块 //局部变量 - 定义在方法体内部 int a= 10; &#123;// 使用的范围就是在它所在的最近的那个&#123;&#125;中 int b = 20; System.out.println(a);//ok System.out.println(b);//ok &#125; //使用的范围就是在它所在的最近的那个&#123;&#125;中 //System.out.println(b);//error //访问全局变量 System.out.println(c); //定义一个常量 - 不可改变的量 final int s = 100; //s = 200; //final - b肯定不可变 final byte b = 100; byte result = b + 1;//ok &#125;&#125; 运算符算术运算符12345678910111213141516171819201. + java语言中唯一重载[具有多个意义]的运算符 数值之间表示的加法运算,如果出现了&quot;字符串&quot;,表示拼接[后面就会知道拼接效率很低] 2. - 减法 * 乘法 3. / 除法[配合计算过程中需要注意的结果的类型而已] - 取整 4. % 取余/模 /和%结合使用,可以获取某个数字任意位上的数值. 5. += -= *= /= %= 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 6. ++和-- 前++/后++ - 变量本身都会自增1 前--/后-- - 变量本身都会自减1 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 比较运算符12&gt; &lt;= &gt;= &lt; !=比较得到的结果是一个boolean类型即可 逻辑运算符 &amp;&amp; - 逻辑与,短路与.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 所有的条件表达式都是返回true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为false的放在最左边 - 提高代码的执行效率. || - 逻辑或,短路或.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 只要有一个表达式是true,那么结果就是true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为true的放在最左边 - 提高代码的执行效率. ! - 逻辑非,true成为false,false成为true 位运算符 &amp; - 按位&amp;,非短路与,最主要的作用就是用来计算的,但是可以用来连接条件表达式. ​ 计算:都是1,结果才是1.只要出现1个0,那么结果就是0 ​ 连接条件:为true - 所有的条件表达式都是返回true 1234567891011121310 &amp; 8 = 8 十进制的数不断除以2,直到商为0,然后倒过来取余数 - 101010 / 2 = 商5......余05 / 2 = 商2 ...... 12/ 2 = 1 ........ 01/2 = 0 .........1 1 0 1 0 &amp; 1 0 0 0------------------ 1 0 0 0 -&gt; 对应的十进制8 | - 按位或,非短路或,最主要的作用就是用来计算的,但是可以用来连接条件表达式. 计算:只要存在一个1,结果就是1 连接条件:为true - 只要存在一个条件表达式为true. 123456710 | 8 = ? 1 0 1 0| 1 0 0 0------------------ 1 0 1 0 -&gt; 对应的十进制10 异或^ 作用:进行计算的 - 相同为0,不同为1 12345610 ^ 8 = 2 1 0 1 0 | 1 0 0 0------------------ 0 0 1 0 -&gt; 2 10 ^ 8 ^ 8 = 10 12340 0 1 0 1 0 0 0----------------- 1 0 1 0 -&gt; 10 结论:一个数字连续异或同一个数字俩次结果是它本身. 可以进行加密和解密的操作 注：1234567891011121314151617181920212223package student.aistar.day01;/* *@Auther Zhourui *@data 2021/7/16 19:20 *@Email 1605576647@qq.com */public class ChangeVarValue &#123; public static void main(String[] args) &#123; //使用第三方变量 int a=3,b=4,temp; temp=a; a=b; b=temp; System.out.println(&quot;a:&quot; + a); System.out.println(&quot;b:&quot; + b); //不使用第三方变量 int x=100,y=200; x=x^y; y=x^y; x=x^y; System.out.println(&quot;x:&quot; + x); System.out.println(&quot;y:&quot; + y);&#125; &#125; 取反~,1变0,0变成1 补码 - 负数在计算机中的表现形式就是以补码的形式存在的 123456789101112131415161718192021222324252627282930补码 = 反码 + 1;反码 = 原码符号位不变,其余位依次取反符号位 - 最高位代表的是符号位.1代表的是负数,0代表的是正数.反码本身没有意义的,它的存在就是为了计算补码正数的补码,反码,原码都是它本身.计算一下:-10的二进制是多少?-10的补码是多少?计算步骤:1. -10原码 10000000 00000000 00000000 000010102. -10的反码 10000000 00000000 00000000 00001010 11111111 11111111 11111111 111101013. -10的补码 = 反码+1 11111111 11111111 11111111 11110101 + 1 ------------------------------------- 11111111 11111111 11111111 11110110 -&gt; -10的二进制计算~900000000 00000000 00000000 0000100111111111 11111111 11111111 11110110 -&gt; ~9取反的结果-10 = ~9结论:-(x+1) = ~x 移位操作 笔试题 - 计算性能最高的操作,jdk源码里面很多都是移位操作 1234567891011121314151617181920&lt;&lt; 向左移动2&lt;&lt;2 =&gt; 0010 &lt;&lt; 2 = 1000 = 8原题:请你用最高性能的方式计算出2的3次方.&gt;&gt; 带符号的右移动,向右移动多少位,那么就在最高位补符号位-10 &gt;&gt; 2 = -311111111 11111111 11111111 11110110 &gt;&gt; 211111111 11111111 11111111 11111101 -&gt; 负数的二进制,最高位是100000000 00000000 00000000 00000010 取反 ~2=-3&gt;&gt;&gt; 不带符号的右移动,向右移动多少位,就在最高位补0 -10 &gt;&gt;&gt; 2 10000000 00000000 00000000 00001010 11111111 11111111 11111111 11110110 &gt;&gt; 2 00111111 11111111 11111111 11111101 -&gt; 计算出十进制 01000000 00000000 00000000 00000000 - 3----------------------------------------- 1073741821 方法 - Method 非常重要,如果没有跟上,直接出局. 相当于其他语言中函数function,功能是用来封装代码的逻辑. 把一段代码封装到方法中,方便以后复用,提高了代码的可维护性. 语法1234修饰符 返回类型 方法名([参数列表]) [throws 可抛出的异常列表]&#123;..方法体...&#125;现阶段:修饰符 返回类型 方法名([参数列表])&#123;..方法体...&#125; 修饰符访问修饰符 作用:就是决定了这个方法可以被调用的范围. public - 公开的,公共的.如果一个方法被public进行了修饰,那么代表这个方法可以在别的地方被调用. private - 私有的,只能在当前类内部被调用 - 体现了”封装性” - 不对外公开的. 默认的 受保护的 特殊修饰符[超纲的内容] static - 静态的 如果使用static修饰的方法 - 静态方法 如果没有使用static修饰的方法 - 非静态方法 是否为静态的方法决定了这个方法被调用的方式. 返回类型 有返回类型 可以是八种基本数据类型,也可以是对象类型[内置对象类型或者自定义对象类型] 方法体的最终的出口一定有return 返回值. 12345678return 作用1 - 返回方法最终的执行结果 作用2 - 用来结束整个方法正常情况方法的返回类型是什么,返回值的结果的类型也应该是什么非正常情况 - 支持类型的自动转换和强制类型转换的.调用的时候 - 需要使用数据类型和变量来接受这个方法调用的结果. 方法的返回类型是什么,就用什么类型去定义.当然也是支持类型的转换 无返回类型 - void 1不需要使用return + 返回值; 该如何选择? 如果某个方法的执行结果可能在另外一个地方被使用到,那么一定要定义成有返回类型 如果一个方法仅仅是为了输出,只要定义void 12public static int test01(int m,int n)&#123; //code... return m和n的最大公约数 //System.out.println(公约数) } //int m = test01(20,12);//m-&gt;4 public static int test02(int m,int n){ int 公约数 = test01(m,n); return mn/公约数; } int n = test02(20,12);//n-&gt;60=2012/4=60 1 方法名 参考变量名的命名规则 - 一模一样 标识符 - 给类,包,变量,方法取的名称 参数列表 无参列表 带参列表 可变长列表 该如何定义方法 方法体内部不能够再去定义方法了 main方法仍然是程序的主入口. 自定义的方法希望能够被调用,那么最终肯定是在main方法中进行调用的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package student.aistar.day01;/* *@Auther Zhourui *@data 2021/7/16 19:40 *@Email 1605576647@qq.com */ public class MethodHelloDemo &#123; /** * main - 仍然是程序的主入口 * @param args */ public static void main(String[] args) &#123; //类中的方法 - 类里面的成员 //static - 静态的成员被初始化的时机 //静态方法什么时候被初始化的? - 当JVM加载类进内存的时候,就会立即给所有的静态的成员分配空间以及初始化 //在这个阶段,压根就没有对象的概念,只有类. //结论 - 静态的成员属于类的,并且初始化的时机有且1次. //属于谁,就由谁去调用! //1. 调用静态的方法,直接通过类.方法名([参数]) //类 - 该静态方法所在的当前类 MethodHelloDemo.sub(); //non-static -&gt; 非静态的成员被初始化的时机? //当遇到创建对象的语法.每次创建对象的时候,都会给各自的非静态成员分配空间以及初始化 //如果没有创建对象,就不会初始化这些非静态成员. //结论: 非静态成员是属于对象的.属于谁,由谁调用. //2. 非静态方法 - 通过对象去调用 //调用哪个类中的方法,就去创建哪个类的对象 //后面的OO知识点 -&gt; 类名 变量 = new 类名(); //创建了一个 MethodHelloDemo对象,m就是对象名 MethodHelloDemo m = new MethodHelloDemo(); m.add(); &#125; /** * 定义了公开的非静态的无返回类型的方法 */ public void add()&#123; System.out.println(&quot;add...&quot;); &#125; /** * 定义了公开的静态的无返回类型的方法 */ public static void sub()&#123; System.out.println(&quot;sub...&quot;); &#125;&#125; 注： 静态方法中只能够直接调用静态方法 非静态方法中可以直接调用非静态方法以及静态方法 通用的原则 - 类名.静态方法或者对象.非静态方法 静态方法属于类拥有的,非静态方法属于对象拥有的 静态的方法是jvm加载类进内存的时候就会立即被分配空间以及初始化,并且机会仅仅只有1次. 而非静态方法必须是等到创建对象的时候,才会被分配空间以及初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package student.aistar.day01;/* *@Auther Zhourui *@data 2021/7/16 19:44 *@Email 1605576647@qq.com */public class StaticDetailDemo &#123; //定义了全局变量 //属性,方法 =&gt; 成员 //非静态的属性 int n = 10;//等创建对象的时候,才会分配空间和初始化 //静态属性-初始化的时机优先于静态方法 static int m = 100; public static void main(String[] args) &#123; //此时n还未初始化 //System.out.println(n);//编译错误 //System.out.println(m); //调用test03 - 非静态的 StaticDetailDemo s = new StaticDetailDemo(); s.test03(); System.out.println(s); &#125; //非静态的 public void test01()&#123; System.out.println(&quot;test01..&quot;); &#125; //静态的 public static void test02()&#123; int n = 10; System.out.println(&quot;test02...&quot;); //自定义的方法中是可以调用自己自定义的方法的 //1. 另外一个静态方法test04 StaticDetailDemo.test04(); //静态方法中可以直接调用静态方法 test04(); //2. 另外一个非静态方法test03 StaticDetailDemo s1 = new StaticDetailDemo(); s1.test03(); &#125; public void test03()&#123; //static int n = 20;//非静态方法中不允许定义静态的局部变量 System.out.println(&quot;test03..&quot;); //非静态方法中调用静态方法 - 类名.方法 //StaticDetailDemo.test04();//ok test04();//ok //非静态方法中直接调用另外一个非静态方法呢??? - 肯定是需要一个对象去调用. test01();//ok //实际上省略了一个关键字this //this代表的是当前对象 //当前对象 - 调用该方法[test03]的对象 //this.test01(); System.out.println(this); &#125; public static void test04()&#123; System.out.println(&quot;test04..&quot;); &#125;&#125; 方法调用补充 方法的调用者和方法的定义者在同一个类中. 方法的调用者和方法的定义者不在同一个类中,但是仍然在同一个package中. 只能使用通用的原则类名.静态方法或者对象.非静态方法 方法的调用者和方法的定义者是存在于不同包下的不同类中. 必须先通过import关键字进行导包操作. 使用jdk中的类的时候,除了java.lang包下的不需要手动import,其余包下的都需要先import 递归算法 - 错误的写法 - 方法内部直接调用自己 private 和 public 该选择使用123456789101112131415161718192021222324252627public class 牛叉的工具类&#123; public static void 牛叉的方法01()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //.. //... &#125; private static void 小的牛叉方法01()&#123; //专门封装了小的功能. &#125; public static void 牛叉的方法02()&#123; //肯定是会被外面的人调用的... //内部的代码的业务逻辑非常负责,由很多小的功能组成的 小的牛叉方法01(); //... //... //... &#125;&#125;","categories":[],"tags":[{"name":"JAVA学习","slug":"JAVA学习","permalink":"http://example.com/tags/JAVA%E5%AD%A6%E4%B9%A0/"}]},{"title":"git_hexo","slug":"hexo+github搭建博客服务器","date":"2021-07-13T07:12:52.000Z","updated":"2021-07-13T07:14:00.567Z","comments":true,"path":"2021/07/13/hexo+github搭建博客服务器/","link":"","permalink":"http://example.com/2021/07/13/hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"hexo+github搭建博客服务器 csdn,简书,有道笔记 - 广告比较多 hexo+github[比较慢,翻墙]/gitee[Git pages服务器 - 维护]/阿里云服务器 安装nodejs 非中文的非特殊字符的目录中[目录中不要出现空格或者带有特殊符号的] D:/node-v14.17.3-win-x64 环境变量的配置 桌面计算机 - 右击 - 属性 - 高级系统设置 - 环境变量(N) 定位到下方的系统变量 定位到变量名 - Path - 编辑 - 新建 D:/node-v14.17.3-win-x64 一定要关闭所有的环境变量配置的窗口 - 确定 打开终端[如果终端已经打开了,关闭 - 重新打开] win[微软图标]+r - 输入cmd - 输入如下指令检测nodejs是否配置成功 12345npm -v6.14.5 出现版本号,则说明配置成功如果出现了不是内部或者外部的命令的同学,请检查自己的nodejs解压缩之后的路径是否成功配置到了path中 简单认识npm npm是javascript的一个**包[前端框架]**管理工具,并且是nodejs平台默认的包管理工具. 通过npm可以安装,共享,分发代码,管理项目依赖关系. 类似于java中的maven或者gradle[强大的项目构建工具以及项目依赖管理工具] npm简单使用修改镜像 为了下载速度变快,修改npm的镜像 1npm config set registry https://registry.npm.taobao.org 验证一下,镜像是否成功修改了 123npm config get registryhttps://registry.npm.taobao.org/ 简单使用 - 不需要操作 下载bootstrap npm install 框架名称 - 默认下载的是最新的版本 1npm install bootstrap@3 Hexo官网 https://hexo.io/zh-cn/docs/ 安装 假设你在D盘根目录下新建了一个文件夹hello-hexo[博客项目的根目录] win+r - 打开终端 通过dos命令进入到hello-hexo目录中 123C:/User/admin&gt;d:D:&gt;cd hello-hexoD:/hello-hexo&gt;npm install hexo-cli -g 创建真正的博客目录1D:/hello-hexo&gt;hexo init hello-blog 12cd hello-blogD:/hello-hexo/hello-blog&gt;npm install 测试 - 启动博客服务器1D:/hello-hexo/hello-blog&gt;hexo s 关闭服务器 1ctrl+c 打开浏览器输入:localhost:4000 常用主题模板 https://blog.csdn.net/zgd826237710/article/details/99671027 使用git命令来进行克隆,需要提前安装好git,检测git是否安装成功,重新打开终端 1git --version 注册码云账号 推荐用QQ注册一下 本地配置码云账号信息 - 配置文件 - 位置windows的用户主目录下 C:/User/计算机用户名 - 观察是否存在**.gitconfig**文件,添加如下内容 1[user] email = 码云的QQ邮箱 name = 用户名 安装模板 通过cmd进入到hello-blog目录中的themes目录中 1D:/hello-hexo/hello-blog&gt;cd themesD://hello-hexo/hello-blog/themes&gt;git clone https://gitee.com/guancg/hexo-theme-pure.git 或者直接从github上直接clone 1git clone https://github.com/cofess/hexo-theme-pure.git 更新主题配置 指定新的主题 hello-blog目录下的_config.yml文件 1theme: hexo-theme-pure 重启服务器hexo s 个人信息hexo-theme-pure/_config.yml文件 1overriden author: 亲爱的管管 author_title: 高级打字员 author_description: 个人简介。 location: SuZhou, China Markdown语法 语法的编辑器 - https://typora.io/ 文件的后缀是md 1常用语法如下:1. 标题的语法:1~6标题 - # 一级标题 ## 二级标题 2. 代码块 - java,js,mysql...​~~~java 敲enter键3. 列表3-1. 无序列表 * 列表名称 有序列表 1. 列表名称4. 高亮显示 `高亮显示内容`5. 加粗字体 **粗体**6. 斜体 *斜体*7. 粗+斜 ***粗斜***8. 段落 &gt; 空格9. 引入外部图片 ![](xx.png)10. 表格 新建博文1D://hello-hexo/hello-blog&gt;hexo n java 效果:hello-blog目录下的source/_ports/自动生成一个java.md文件 重启blog服务器 1D://hello-hexo/hello-blog&gt;hexo s 主题的侧边栏 侧边栏的链接生效 将/hello-blog/themes/hexo-theme-pure/_source/下的除了_data文件夹,其余文件夹 拷贝一份放入到hello-blog目录下的source目录中即可 文章的分类和标签 只需要在文章的.md文件的自动生成的头部添加 1title: javadate: 2021-07-13 08:44:42categories: javatags: java 博客的语言环境设置 设置中文 hello-blog下的_config.yml文件中 language: zh-CN 图片显示问题 安装插件 - npm install https://gitee.com/guancg/hexo-asset-image.git –save 需要到hello-blog/_config.yml文件中进行配置 1post_asset_folder: true hexo n 机器学习 效果就是除了生成了机器学习.md还有一个机器学习文件夹,那么这篇文章的所有的图片就可以存储在机器学习文件夹中 hexo s 内置搜索的功能 1# Searchsearch:insight: true # you need to install `hexo-generator-json-content` before using Insight Searchbaidu: false # you need to disable other search engines to use Baidu search 安装内置搜索插件 npm i -S hexo-generator-json-content 评论 不需要本地数据库进行存储的,用的是第三方的. LeanCloud - 官网地址 - https://www.leancloud.cn/ 注册 - 登录 - 控制台 - 创建应用 - 右下设置 - 应用凭证 appId - sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz appKey - 3hn4ijEgSzJeRV4nkmXThmGV 在hexo-theme-pure\\_config.yml文件中配置 1valine: # Valine. https://valine.js.org appid: sljUq97vUAdLAo7XQdf13aFR-gzGzoHsz # your leancloud application appid appkey: 3hn4ijEgSzJeRV4nkmXThmGV# your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style meta: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true # Article reading statistic https://valine.js.org/visitor.html #字数统计&amp;阅读时长 npm i -S hexo-wordcount hexo-theme-pure_config.yml文件中配置 1postCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 附件-优秀插件 显示图片 1npm install https://gitee.com/guancg/hexo-asset-image.git --save 内置搜索 1npm i -S hexo-generator-json-content 字数统计&amp;阅读时长 1npm i -S hexo-wordcount github部署 1npm install hexo-deployer-git --save github注册一下 github.com chrome浏览器 + iguge - https://iguge.app/ 新建的仓库的名称必须是guancgsuccess.github.io 仓库地址 - https://github.com/guancgsuccess/guancgsuccess.github.io.git 安装github部署插件 npm install hexo-deployer-git –save hello-blog/_config.yml文件 1deploy:type: &#x27;git&#x27;repo: &#x27;https://github.com/guancgsuccess/guancgsuccess.github.io.git&#x27;branch: &#x27;master&#x27; hexo三连操作 1hexo clhexo ghexo shexo d 浏览器输入 - guancgsuccess.github.io","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"喵喵","slug":"喵喵","date":"2021-07-13T02:05:09.000Z","updated":"2021-07-13T02:08:14.877Z","comments":true,"path":"2021/07/13/喵喵/","link":"","permalink":"http://example.com/2021/07/13/%E5%96%B5%E5%96%B5/","excerpt":"","text":"我是一只喵喵","categories":[{"name":"喵喵","slug":"喵喵","permalink":"http://example.com/categories/%E5%96%B5%E5%96%B5/"}],"tags":[{"name":"喵喵","slug":"喵喵","permalink":"http://example.com/tags/%E5%96%B5%E5%96%B5/"}]},{"title":"测试","slug":"测试","date":"2021-07-13T01:08:51.000Z","updated":"2021-07-13T01:24:45.046Z","comments":true,"path":"2021/07/13/测试/","link":"","permalink":"http://example.com/2021/07/13/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"测试第一期","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-12T06:45:08.218Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2021/07/12/hello-world/","link":"","permalink":"http://example.com/2021/07/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"喵喵","slug":"喵喵","permalink":"http://example.com/categories/%E5%96%B5%E5%96%B5/"},{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"面试","slug":"面试","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JAVA学习","slug":"JAVA学习","permalink":"http://example.com/tags/JAVA%E5%AD%A6%E4%B9%A0/"},{"name":"其他","slug":"其他","permalink":"http://example.com/tags/%E5%85%B6%E4%BB%96/"},{"name":"喵喵","slug":"喵喵","permalink":"http://example.com/tags/%E5%96%B5%E5%96%B5/"},{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]}